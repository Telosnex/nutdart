#import <Foundation/Foundation.h>
#import <AppKit/AppKit.h>
#import "../../screencapturekit_bridge.h"
#if __has_include(<ScreenCaptureKit/ScreenCaptureKit.h>)
#import <ScreenCaptureKit/ScreenCaptureKit.h>
#import "computer_use-Swift.h"
#endif
#include <stdlib.h>

CUBitmap* copyBitmapFullDisplay_SCK(void) {
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 120300
    if (@available(macOS 12.3, *)) {
        NSLog(@"ScreenCaptureKit: Attempting capture...");
        NSData* data = [ScreenCaptureKitWrapper captureMainDisplayRGB];
        if (!data) {
            NSLog(@"ScreenCaptureKit: No data returned");
            return NULL;
        }
        NSLog(@"ScreenCaptureKit: Got %lu bytes", (unsigned long)data.length);
        // We don't know width/height here; currently ScreenCaptureKitWrapper uses main display size
        NSScreen* mainScreen = [NSScreen mainScreen];
        if (!mainScreen) return NULL;
        CGSize size = mainScreen.frame.size;
        CUBitmap* bmp = (CUBitmap*)malloc(sizeof(CUBitmap));
        if (!bmp) return NULL;
        bmp->width = (int64_t)size.width;
        bmp->height = (int64_t)size.height;
        bmp->bytewidth = bmp->width * 3;
        bmp->bitsPerPixel = 24;
        bmp->bytesPerPixel = 3;
        bmp->data = (uint8_t*)malloc(data.length);
        if (!bmp->data) { free(bmp); return NULL; }
        memcpy(bmp->data, data.bytes, data.length);
        return bmp;
    }
#endif
    return NULL;
}

void destroyBitmap_SCK(CUBitmap* bmp) {
    if (!bmp) return;
    if (bmp->data) free(bmp->data);
    free(bmp);
}

// Helper function to resize NSImage and convert to JPEG
NSData* resizeImageAndConvertToJPEG(NSImage* image, int32_t maxSmallDim, int32_t maxLargeDim, int32_t quality) {
    if (!image) {
        return nil;
    }
    
    NSSize originalSize = image.size;
    NSSize newSize = originalSize;
    
    // Calculate new size based on constraints
    if (maxSmallDim > 0 || maxLargeDim > 0) {
        CGFloat width = originalSize.width;
        CGFloat height = originalSize.height;
        CGFloat smallDim = MIN(width, height);
        CGFloat largeDim = MAX(width, height);
        
        CGFloat scale = 1.0;
        
        // Apply small dimension constraint
        if (maxSmallDim > 0 && smallDim > maxSmallDim) {
            scale = MIN(scale, (CGFloat)maxSmallDim / smallDim);
        }
        
        // Apply large dimension constraint
        if (maxLargeDim > 0 && largeDim > maxLargeDim) {
            scale = MIN(scale, (CGFloat)maxLargeDim / largeDim);
        }
        
        newSize = NSMakeSize(width * scale, height * scale);
    }
    
    // Create a resized NSImage first
    NSImage* resizedImage = [[NSImage alloc] initWithSize:newSize];
    [resizedImage lockFocus];
    [image drawInRect:NSMakeRect(0, 0, newSize.width, newSize.height)
             fromRect:NSZeroRect
            operation:NSCompositingOperationCopy
             fraction:1.0];
    [resizedImage unlockFocus];
    
    // Get bitmap representation from the resized image
    NSBitmapImageRep* bitmapRep = nil;
    NSData* tiffData = [resizedImage TIFFRepresentation];
    if (tiffData) {
        bitmapRep = [NSBitmapImageRep imageRepWithData:tiffData];
    } else {
        return nil;
    }
    
    // Convert to JPEG
    NSDictionary* properties = @{
        NSImageCompressionFactor: @(quality / 100.0)
    };
    
    NSData* jpegData = [bitmapRep representationUsingType:NSBitmapImageFileTypeJPEG properties:properties];
    
    return jpegData;
}

uint8_t* copyBitmapRegionJpeg_SCK(int64_t x, int64_t y, int64_t width, int64_t height,
                                  int32_t maxSmallDim, int32_t maxLargeDim, 
                                  int32_t quality, int64_t* outSize) {
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 120300
    if (@available(macOS 12.3, *)) {
        // For now, we'll capture the full screen and crop it
        // A more efficient implementation would capture only the region
        NSData* fullScreenData = [ScreenCaptureKitWrapper captureMainDisplayRGB];
        if (!fullScreenData) {
            if (outSize) *outSize = 0;
            return NULL;
        }
        
        NSScreen* mainScreen = [NSScreen mainScreen];
        if (!mainScreen) {
            if (outSize) *outSize = 0;
            return NULL;
        }
        
        CGSize screenSize = mainScreen.frame.size;
        
        // Create NSImage from RGB data
        // First create an empty bitmap rep
        NSBitmapImageRep* imageRep = [[NSBitmapImageRep alloc]
            initWithBitmapDataPlanes:NULL
                          pixelsWide:screenSize.width
                          pixelsHigh:screenSize.height
                       bitsPerSample:8
                     samplesPerPixel:3
                            hasAlpha:NO
                            isPlanar:NO
                      colorSpaceName:NSCalibratedRGBColorSpace
                         bytesPerRow:screenSize.width * 3
                        bitsPerPixel:24];
        
        // Copy the RGB data into the bitmap rep
        unsigned char* bitmapData = [imageRep bitmapData];
        memcpy(bitmapData, fullScreenData.bytes, fullScreenData.length);
        
        NSImage* fullImage = [[NSImage alloc] init];
        [fullImage addRepresentation:imageRep];
        
        // Crop to the specified region
        NSRect cropRect = NSMakeRect(x, screenSize.height - y - height, width, height); // Flip Y coordinate
        NSImage* croppedImage = [[NSImage alloc] initWithSize:NSMakeSize(width, height)];
        [croppedImage lockFocus];
        [fullImage drawInRect:NSMakeRect(0, 0, width, height)
                     fromRect:cropRect
                    operation:NSCompositingOperationCopy
                     fraction:1.0];
        [croppedImage unlockFocus];
        
        // Resize and convert to JPEG
        NSData* jpegData = resizeImageAndConvertToJPEG(croppedImage, maxSmallDim, maxLargeDim, quality);
        
        if (!jpegData) {
            if (outSize) *outSize = 0;
            return NULL;
        }
        
        // Allocate and copy JPEG data
        uint8_t* result = (uint8_t*)malloc(jpegData.length);
        if (!result) {
            if (outSize) *outSize = 0;
            return NULL;
        }
        
        memcpy(result, jpegData.bytes, jpegData.length);
        if (outSize) *outSize = jpegData.length;
        
        return result;
    }
#endif
    if (outSize) *outSize = 0;
    return NULL;
}

uint8_t* copyBitmapFullJpeg_SCK(int32_t maxSmallDim, int32_t maxLargeDim, 
                                int32_t quality, int64_t* outSize) {
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 120300
    if (@available(macOS 12.3, *)) {
        NSLog(@"DEBUG: copyBitmapFullJpeg_SCK called with maxSmallDim=%d, maxLargeDim=%d, quality=%d", maxSmallDim, maxLargeDim, quality);
        NSData* rgbData = [ScreenCaptureKitWrapper captureMainDisplayRGB];
        if (!rgbData) {
            if (outSize) *outSize = 0;
            return NULL;
        }
        
        NSScreen* mainScreen = [NSScreen mainScreen];
        if (!mainScreen) {
            if (outSize) *outSize = 0;
            return NULL;
        }
        
        CGSize screenSize = mainScreen.frame.size;
        
        // Create NSImage from RGB data
        // First create an empty bitmap rep
        NSBitmapImageRep* imageRep = [[NSBitmapImageRep alloc]
            initWithBitmapDataPlanes:NULL
                          pixelsWide:screenSize.width
                          pixelsHigh:screenSize.height
                       bitsPerSample:8
                     samplesPerPixel:3
                            hasAlpha:NO
                            isPlanar:NO
                      colorSpaceName:NSCalibratedRGBColorSpace
                         bytesPerRow:screenSize.width * 3
                        bitsPerPixel:24];
        
        // Copy the RGB data into the bitmap rep
        unsigned char* bitmapData = [imageRep bitmapData];
        if (!bitmapData) {
            if (outSize) *outSize = 0;
            return NULL;
        }
        
        memcpy(bitmapData, rgbData.bytes, rgbData.length);
        
        NSImage* image = [[NSImage alloc] init];
        [image addRepresentation:imageRep];
        
        // Resize and convert to JPEG
        NSData* jpegData = resizeImageAndConvertToJPEG(image, maxSmallDim, maxLargeDim, quality);
        
        if (!jpegData) {
            if (outSize) *outSize = 0;
            return NULL;
        }
        
        // Allocate and copy JPEG data
        uint8_t* result = (uint8_t*)malloc(jpegData.length);
        if (!result) {
            if (outSize) *outSize = 0;
            return NULL;
        }
        
        memcpy(result, jpegData.bytes, jpegData.length);
        if (outSize) *outSize = jpegData.length;
        
        return result;
    }
#endif
    if (outSize) *outSize = 0;
    return NULL;
}

void freeJpegData_SCK(uint8_t* data) {
    if (data) {
        free(data);
    }
}
